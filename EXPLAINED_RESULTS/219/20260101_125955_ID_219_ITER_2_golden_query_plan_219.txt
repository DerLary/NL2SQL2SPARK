
Execution Plan for: Golden Query ID 219...
================================================================================

1. Logical plan:
----------------------------------------
'Project [unresolvedalias(((cast('COUNT(distinct CASE WHEN ('T2.label = +) THEN 'T2.molecule_id ELSE null END) as float) * 100) / 'COUNT(distinct 'T2.molecule_id)))]
+- 'Filter ('T3.bond_type = #)
   +- 'Join Inner, ('T2.molecule_id = 'T3.molecule_id)
      :- 'Join Inner, ('T1.molecule_id = 'T2.molecule_id)
      :  :- 'SubqueryAlias T1
      :  :  +- 'UnresolvedRelation [atom], [], false
      :  +- 'SubqueryAlias T2
      :     +- 'UnresolvedRelation [molecule], [], false
      +- 'SubqueryAlias T3
         +- 'UnresolvedRelation [bond], [], false


2. Optimized logical plan (After Catalyst AFAIK):
----------------------------------------
Aggregate [((cast(count(CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796) FILTER (WHERE (gid#31794 = 2)) as double) * 100.0) / cast(count(T2.molecule_id#31795) FILTER (WHERE (gid#31794 = 1)) as double)) AS ((CAST(count(DISTINCT CASE WHEN (label = +) THEN molecule_id ELSE NULL END) AS FLOAT) * 100) / count(DISTINCT molecule_id))#31793]
+- Aggregate [T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794], [T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794]
   +- Expand [[molecule_id#31789, null, 1], [null, CASE WHEN (label#31790 = +) THEN molecule_id#31789 END, 2]], [T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794]
      +- Project [molecule_id#31789, label#31790]
         +- Join Inner, (molecule_id#31789 = molecule_id#31784)
            :- Project [molecule_id#31789, label#31790]
            :  +- Join Inner, (molecule_id#31781 = molecule_id#31789)
            :     :- Project [molecule_id#31781]
            :     :  +- Filter isnotnull(molecule_id#31781)
            :     :     +- Relation [atom_id#31780,molecule_id#31781,element#31782] JDBCRelation((SELECT "atom_id", "molecule_id", "element" FROM "atom") AS "atom") [numPartitions=1]
            :     +- Filter isnotnull(molecule_id#31789)
            :        +- Relation [molecule_id#31789,label#31790] JDBCRelation((SELECT "molecule_id", "label" FROM "molecule") AS "molecule") [numPartitions=1]
            +- Project [molecule_id#31784]
               +- Filter ((isnotnull(bond_type#31785) AND (bond_type#31785 = #)) AND isnotnull(molecule_id#31784))
                  +- Relation [bond_id#31783,molecule_id#31784,bond_type#31785] JDBCRelation((SELECT "bond_id", "molecule_id", "bond_type" FROM "bond") AS "bond") [numPartitions=1]


3. Physical plan:
----------------------------------------
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[], functions=[count(CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796), count(T2.molecule_id#31795)], output=[((CAST(count(DISTINCT CASE WHEN (label = +) THEN molecule_id ELSE NULL END) AS FLOAT) * 100) / count(DISTINCT molecule_id))#31793])
  +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=54405]
      +- HashAggregate(keys=[], functions=[partial_count(CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796) FILTER (WHERE (gid#31794 = 2)), partial_count(T2.molecule_id#31795) FILTER (WHERE (gid#31794 = 1))], output=[count#31799L, count#31800L])
        +- HashAggregate(keys=[T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794], functions=[], output=[T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794])
            +- Exchange hashpartitioning(T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794, 200), ENSURE_REQUIREMENTS, [plan_id=54401]
              +- HashAggregate(keys=[T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794], functions=[], output=[T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794])
                  +- Expand [[molecule_id#31789, null, 1], [null, CASE WHEN (label#31790 = +) THEN molecule_id#31789 END, 2]], [T2.molecule_id#31795, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31796, gid#31794]
                    +- Project [molecule_id#31789, label#31790]
                        +- SortMergeJoin [molecule_id#31789], [molecule_id#31784], Inner
                          :- Project [molecule_id#31789, label#31790]
                          :  +- SortMergeJoin [molecule_id#31781], [molecule_id#31789], Inner
                          :     :- Sort [molecule_id#31781 ASC NULLS FIRST], false, 0
                          :     :  +- Exchange hashpartitioning(molecule_id#31781, 200), ENSURE_REQUIREMENTS, [plan_id=54386]
                          :     :     +- Scan JDBCRelation((SELECT "atom_id", "molecule_id", "element" FROM "atom") AS "atom") [numPartitions=1] [molecule_id#31781] PushedFilters: [*IsNotNull(molecule_id)], ReadSchema: struct<molecule_id:string>
                          :     +- Sort [molecule_id#31789 ASC NULLS FIRST], false, 0
                          :        +- Exchange hashpartitioning(molecule_id#31789, 200), ENSURE_REQUIREMENTS, [plan_id=54387]
                          :           +- Scan JDBCRelation((SELECT "molecule_id", "label" FROM "molecule") AS "molecule") [numPartitions=1] [molecule_id#31789,label#31790] PushedFilters: [*IsNotNull(molecule_id)], ReadSchema: struct<molecule_id:string,label:string>
                          +- Sort [molecule_id#31784 ASC NULLS FIRST], false, 0
                              +- Exchange hashpartitioning(molecule_id#31784, 200), ENSURE_REQUIREMENTS, [plan_id=54394]
                                +- Scan JDBCRelation((SELECT "bond_id", "molecule_id", "bond_type" FROM "bond") AS "bond") [numPartitions=1] [molecule_id#31784] PushedFilters: [*IsNotNull(bond_type), *EqualTo(bond_type,#), *IsNotNull(molecule_id)], ReadSchema: struct<molecule_id:string>

4. Explain output:
----------------------------------------

Physical Plan ==:
-----------------
  AdaptiveSparkPlan isFinalPlan=false
  +- HashAggregate(keys=[], functions=[count(CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31810), count(T2.molecule_id#31809)])
  +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=54485]
  +- HashAggregate(keys=[], functions=[partial_count(CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31810) FILTER (WHERE (gid#31808 = 2)), partial_count(T2.molecule_id#31809) FILTER (WHERE (gid#31808 = 1))])
  +- HashAggregate(keys=[T2.molecule_id#31809, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31810, gid#31808], functions=[])
  +- Exchange hashpartitioning(T2.molecule_id#31809, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31810, gid#31808, 200), ENSURE_REQUIREMENTS, [plan_id=54481]
  +- HashAggregate(keys=[T2.molecule_id#31809, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31810, gid#31808], functions=[])
  +- Expand [[molecule_id#31789, null, 1], [null, CASE WHEN (label#31790 = +) THEN molecule_id#31789 END, 2]], [T2.molecule_id#31809, CASE WHEN (T2.label = '+') THEN T2.molecule_id END#31810, gid#31808]
  +- Project [molecule_id#31789, label#31790]
  +- SortMergeJoin [molecule_id#31789], [molecule_id#31784], Inner
  :- Project [molecule_id#31789, label#31790]
  :  +- SortMergeJoin [molecule_id#31781], [molecule_id#31789], Inner
  :     :- Sort [molecule_id#31781 ASC NULLS FIRST], false, 0
  :     :  +- Exchange hashpartitioning(molecule_id#31781, 200), ENSURE_REQUIREMENTS, [plan_id=54466]
  :     :     +- Scan JDBCRelation((SELECT "atom_id", "molecule_id", "element" FROM "atom") AS "atom") [numPartitions=1] [molecule_id#31781] PushedFilters: [*IsNotNull(molecule_id)], ReadSchema: struct<molecule_id:string>
  :     +- Sort [molecule_id#31789 ASC NULLS FIRST], false, 0
  :        +- Exchange hashpartitioning(molecule_id#31789, 200), ENSURE_REQUIREMENTS, [plan_id=54467]
  :           +- Scan JDBCRelation((SELECT "molecule_id", "label" FROM "molecule") AS "molecule") [numPartitions=1] [molecule_id#31789,label#31790] PushedFilters: [*IsNotNull(molecule_id)], ReadSchema: struct<molecule_id:string,label:string>
  +- Sort [molecule_id#31784 ASC NULLS FIRST], false, 0
  +- Exchange hashpartitioning(molecule_id#31784, 200), ENSURE_REQUIREMENTS, [plan_id=54474]
  +- Scan JDBCRelation((SELECT "bond_id", "molecule_id", "bond_type" FROM "bond") AS "bond") [numPartitions=1] [molecule_id#31784] PushedFilters: [*IsNotNull(bond_type), *EqualTo(bond_type,#), *IsNotNull(molecule_id)], ReadSchema: struct<molecule_id:string>
================================================================================