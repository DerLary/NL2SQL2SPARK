{
    "query_id": 1482,
    "difficulty": "challenging",
    "is_initial": true,
    "nl_query": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013? Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
    "golden_query": "SELECT CAST((SUM(IF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
    "sparksql_query": "\nSELECT\n  c.`Segment`,\n  SUM(CASE WHEN SUBSTRING(y.`Date`, 1, 4) = '2012' THEN y.`Consumption` ELSE 0 END) AS Consumption_2012,\n  SUM(CASE WHEN SUBSTRING(y.`Date`, 1, 4) = '2013' THEN y.`Consumption` ELSE 0 END) AS Consumption_2013,\n  (SUM(CASE WHEN SUBSTRING(y.`Date`, 1, 4) = '2013' THEN y.`Consumption` ELSE 0 END) - SUM(CASE WHEN SUBSTRING(y.`Date`, 1, 4) = '2012' THEN y.`Consumption` ELSE 0 END)) AS Increase_Decrease,\n  (\n    (CAST(SUM(CASE WHEN SUBSTRING(y.`Date`, 1, 4) = '2013' THEN y.`Consumption` ELSE 0 END) AS DOUBLE) - SUM(CASE WHEN SUBSTRING(y.`Date`, 1, 4) = '2012' THEN y.`Consumption` ELSE 0 END))\n    / NULLIF(CAST(SUM(CASE WHEN SUBSTRING(y.`Date`, 1, 4) = '2013' THEN y.`Consumption` ELSE 0 END) AS DOUBLE), 0)\n  ) * 100 AS Percentage_Increase\nFROM yearmonth AS y\nJOIN customers AS c\n  ON y.`CustomerID` = c.`CustomerID`\nWHERE\n  SUBSTRING(y.`Date`, 1, 4) IN ('2012', '2013')\nGROUP BY\n  c.`Segment`\nORDER BY\n  Percentage_Increase DESC;\n",
    "jaccard_index": 0.0,
    "exact_match": 0,
    "ground_truth": [
        {
            "((CAST((sum((IF(((Segment = SME) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = SME) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = SME) AND Date LIKE 2012%), Consumption, 0))))": 545.4018808857362,
            "((CAST((sum((IF(((Segment = LAM) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = LAM) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = LAM) AND Date LIKE 2012%), Consumption, 0))))": 681.5824507359694,
            "((CAST((sum((IF(((Segment = KAM) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = KAM) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = KAM) AND Date LIKE 2012%), Consumption, 0))))": 708.1124296835188
        }
    ],
    "query_result": [
        [
            "KAM",
            "135424912.7400001",
            "1094385521.0699985",
            "958960608.3299984",
            "87.62548387814991"
        ],
        [
            "LAM",
            "118970734.52000001",
            "929854390.5599992",
            "810883656.0399992",
            "87.20544466662672"
        ],
        [
            "SME",
            "152513750.5300001",
            "984326643.6499959",
            "831812893.1199958",
            "84.50577849193824"
        ]
    ],
    "execution_plans": {
        "golden_query": "\nExecution Plan for: Golden Query ID 1482...\n================================================================================\n\n1. Logical plan:\n----------------------------------------\n'Project [unresolvedalias(((cast(('SUM('IF((('T1.Segment = SME) AND 'T2.Date LIKE 2013%), 'T2.Consumption, 0)) - 'SUM('IF((('T1.Segment = SME) AND 'T2.Date LIKE 2012%), 'T2.Consumption, 0))) as float) * 100) / 'SUM('IF((('T1.Segment = SME) AND 'T2.Date LIKE 2012%), 'T2.Consumption, 0)))), unresolvedalias(((cast(('SUM('IF((('T1.Segment = LAM) AND 'T2.Date LIKE 2013%), 'T2.Consumption, 0)) - 'SUM('IF((('T1.Segment = LAM) AND 'T2.Date LIKE 2012%), 'T2.Consumption, 0))) as float) * 100) / 'SUM('IF((('T1.Segment = LAM) AND 'T2.Date LIKE 2012%), 'T2.Consumption, 0)))), unresolvedalias(((cast(('SUM('IF((('T1.Segment = KAM) AND 'T2.Date LIKE 2013%), 'T2.Consumption, 0)) - 'SUM('IF((('T1.Segment = KAM) AND 'T2.Date LIKE 2012%), 'T2.Consumption, 0))) as float) * 100) / 'SUM('IF((('T1.Segment = KAM) AND 'T2.Date LIKE 2012%), 'T2.Consumption, 0))))]\n+- 'Join Inner, ('T1.CustomerID = 'T2.CustomerID)\n   :- 'SubqueryAlias T1\n   :  +- 'UnresolvedRelation [customers], [], false\n   +- 'SubqueryAlias T2\n      +- 'UnresolvedRelation [yearmonth], [], false\n\n\n2. Optimized logical plan (After Catalyst AFAIK):\n----------------------------------------\nAggregate [((cast(cast((sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0) - sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)) as float) as double) * 100.0) / sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)) AS ((CAST((sum((IF(((Segment = SME) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = SME) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = SME) AND Date LIKE 2012%), Consumption, 0))))#29478, ((cast(cast((sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0) - sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)) as float) as double) * 100.0) / sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)) AS ((CAST((sum((IF(((Segment = LAM) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = LAM) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = LAM) AND Date LIKE 2012%), Consumption, 0))))#29479, ((cast(cast((sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0) - sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)) as float) as double) * 100.0) / sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)) AS ((CAST((sum((IF(((Segment = KAM) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = KAM) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = KAM) AND Date LIKE 2012%), Consumption, 0))))#29480]\n+- Project [Segment#29447, Date#29467, Consumption#29468]\n   +- Join Inner, (CustomerID#29446 = CustomerID#29466)\n      :- Project [CustomerID#29446, Segment#29447]\n      :  +- Filter isnotnull(CustomerID#29446)\n      :     +- Relation [CustomerID#29446,Segment#29447,Currency#29448] JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1]\n      +- Filter isnotnull(CustomerID#29466)\n         +- Relation [CustomerID#29466,Date#29467,Consumption#29468] JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1]\n\n\n3. Physical plan:\n----------------------------------------\nAdaptiveSparkPlan isFinalPlan=false\n+- HashAggregate(keys=[], functions=[sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)], output=[((CAST((sum((IF(((Segment = SME) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = SME) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = SME) AND Date LIKE 2012%), Consumption, 0))))#29478, ((CAST((sum((IF(((Segment = LAM) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = LAM) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = LAM) AND Date LIKE 2012%), Consumption, 0))))#29479, ((CAST((sum((IF(((Segment = KAM) AND Date LIKE 2013%), Consumption, 0))) - sum((IF(((Segment = KAM) AND Date LIKE 2012%), Consumption, 0)))) AS FLOAT) * 100) / sum((IF(((Segment = KAM) AND Date LIKE 2012%), Consumption, 0))))#29480])\n  +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=48532]\n      +- HashAggregate(keys=[], functions=[partial_sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)], output=[sum#29487, sum#29488, sum#29489, sum#29490, sum#29491, sum#29492])\n        +- Project [Segment#29447, Date#29467, Consumption#29468]\n            +- SortMergeJoin [CustomerID#29446], [CustomerID#29466], Inner\n              :- Sort [CustomerID#29446 ASC NULLS FIRST], false, 0\n              :  +- Exchange hashpartitioning(CustomerID#29446, 200), ENSURE_REQUIREMENTS, [plan_id=48524]\n              :     +- Scan JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1] [CustomerID#29446,Segment#29447] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Segment:string>\n              +- Sort [CustomerID#29466 ASC NULLS FIRST], false, 0\n                  +- Exchange hashpartitioning(CustomerID#29466, 200), ENSURE_REQUIREMENTS, [plan_id=48525]\n                    +- Scan JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1] [CustomerID#29466,Date#29467,Consumption#29468] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Date:string,Consumption:double>\n\n4. Explain output:\n----------------------------------------\n\nPhysical Plan ==:\n-----------------\n  AdaptiveSparkPlan isFinalPlan=false\n  +- HashAggregate(keys=[], functions=[sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)])\n  +- Exchange SinglePartition, ENSURE_REQUIREMENTS, [plan_id=48569]\n  +- HashAggregate(keys=[], functions=[partial_sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = SME) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = LAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2013))) Consumption#29468 else 0.0), partial_sum(if (((Segment#29447 = KAM) AND StartsWith(Date#29467, 2012))) Consumption#29468 else 0.0)])\n  +- Project [Segment#29447, Date#29467, Consumption#29468]\n  +- SortMergeJoin [CustomerID#29446], [CustomerID#29466], Inner\n  :- Sort [CustomerID#29446 ASC NULLS FIRST], false, 0\n  :  +- Exchange hashpartitioning(CustomerID#29446, 200), ENSURE_REQUIREMENTS, [plan_id=48561]\n  :     +- Scan JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1] [CustomerID#29446,Segment#29447] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Segment:string>\n  +- Sort [CustomerID#29466 ASC NULLS FIRST], false, 0\n  +- Exchange hashpartitioning(CustomerID#29466, 200), ENSURE_REQUIREMENTS, [plan_id=48562]\n  +- Scan JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1] [CustomerID#29466,Date#29467,Consumption#29468] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Date:string,Consumption:double>\n================================================================================",
        "model_query": "\nExecution Plan for: Model Query ID 1482...\n================================================================================\n\n1. Logical plan:\n----------------------------------------\n'Sort ['Percentage_Increase DESC NULLS LAST], true\n+- 'Aggregate ['c.Segment], ['c.Segment, 'SUM(CASE WHEN ('SUBSTRING('y.Date, 1, 4) = 2012) THEN 'y.Consumption ELSE 0 END) AS Consumption_2012#29521, 'SUM(CASE WHEN ('SUBSTRING('y.Date, 1, 4) = 2013) THEN 'y.Consumption ELSE 0 END) AS Consumption_2013#29522, ('SUM(CASE WHEN ('SUBSTRING('y.Date, 1, 4) = 2013) THEN 'y.Consumption ELSE 0 END) - 'SUM(CASE WHEN ('SUBSTRING('y.Date, 1, 4) = 2012) THEN 'y.Consumption ELSE 0 END)) AS Increase_Decrease#29523, (((cast('SUM(CASE WHEN ('SUBSTRING('y.Date, 1, 4) = 2013) THEN 'y.Consumption ELSE 0 END) as double) - 'SUM(CASE WHEN ('SUBSTRING('y.Date, 1, 4) = 2012) THEN 'y.Consumption ELSE 0 END)) / 'NULLIF(cast('SUM(CASE WHEN ('SUBSTRING('y.Date, 1, 4) = 2013) THEN 'y.Consumption ELSE 0 END) as double), 0)) * 100) AS Percentage_Increase#29524]\n   +- 'Filter 'SUBSTRING('y.Date, 1, 4) IN (2012,2013)\n      +- 'Join Inner, ('y.CustomerID = 'c.CustomerID)\n         :- 'SubqueryAlias y\n         :  +- 'UnresolvedRelation [yearmonth], [], false\n         +- 'SubqueryAlias c\n            +- 'UnresolvedRelation [customers], [], false\n\n\n2. Optimized logical plan (After Catalyst AFAIK):\n----------------------------------------\nSort [Percentage_Increase#29524 DESC NULLS LAST], true\n+- Project [Segment#29447, _aggregateexpression#29525 AS Consumption_2012#29521, _aggregateexpression#29526 AS Consumption_2013#29522, (_aggregateexpression#29526 - _aggregateexpression#29525) AS Increase_Decrease#29523, (((_aggregateexpression#29526 - _aggregateexpression#29525) / if ((_aggregateexpression#29526 = 0.0)) null else _aggregateexpression#29526) * 100.0) AS Percentage_Increase#29524]\n   +- Aggregate [Segment#29447], [Segment#29447, sum(CASE WHEN (substring(Date#29467, 1, 4) = 2012) THEN Consumption#29468 ELSE 0.0 END) AS _aggregateexpression#29525, sum(CASE WHEN (substring(Date#29467, 1, 4) = 2013) THEN Consumption#29468 ELSE 0.0 END) AS _aggregateexpression#29526]\n      +- Project [Date#29467, Consumption#29468, Segment#29447]\n         +- Join Inner, (CustomerID#29466 = CustomerID#29446)\n            :- Filter (substring(Date#29467, 1, 4) IN (2012,2013) AND isnotnull(CustomerID#29466))\n            :  +- Relation [CustomerID#29466,Date#29467,Consumption#29468] JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1]\n            +- Project [CustomerID#29446, Segment#29447]\n               +- Filter isnotnull(CustomerID#29446)\n                  +- Relation [CustomerID#29446,Segment#29447,Currency#29448] JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1]\n\n\n3. Physical plan:\n----------------------------------------\nAdaptiveSparkPlan isFinalPlan=false\n+- Sort [Percentage_Increase#29524 DESC NULLS LAST], true, 0\n  +- Exchange rangepartitioning(Percentage_Increase#29524 DESC NULLS LAST, 200), ENSURE_REQUIREMENTS, [plan_id=48620]\n      +- Project [Segment#29447, _aggregateexpression#29525 AS Consumption_2012#29521, _aggregateexpression#29526 AS Consumption_2013#29522, (_aggregateexpression#29526 - _aggregateexpression#29525) AS Increase_Decrease#29523, (((_aggregateexpression#29526 - _aggregateexpression#29525) / if ((_aggregateexpression#29526 = 0.0)) null else _aggregateexpression#29526) * 100.0) AS Percentage_Increase#29524]\n        +- HashAggregate(keys=[Segment#29447], functions=[sum(CASE WHEN (substring(Date#29467, 1, 4) = 2012) THEN Consumption#29468 ELSE 0.0 END), sum(CASE WHEN (substring(Date#29467, 1, 4) = 2013) THEN Consumption#29468 ELSE 0.0 END)], output=[Segment#29447, _aggregateexpression#29525, _aggregateexpression#29526])\n            +- Exchange hashpartitioning(Segment#29447, 200), ENSURE_REQUIREMENTS, [plan_id=48616]\n              +- HashAggregate(keys=[Segment#29447], functions=[partial_sum(CASE WHEN (substring(Date#29467, 1, 4) = 2012) THEN Consumption#29468 ELSE 0.0 END), partial_sum(CASE WHEN (substring(Date#29467, 1, 4) = 2013) THEN Consumption#29468 ELSE 0.0 END)], output=[Segment#29447, sum#29535, sum#29536])\n                  +- Project [Date#29467, Consumption#29468, Segment#29447]\n                    +- SortMergeJoin [CustomerID#29466], [CustomerID#29446], Inner\n                        :- Sort [CustomerID#29466 ASC NULLS FIRST], false, 0\n                        :  +- Exchange hashpartitioning(CustomerID#29466, 200), ENSURE_REQUIREMENTS, [plan_id=48608]\n                        :     +- Filter substring(Date#29467, 1, 4) IN (2012,2013)\n                        :        +- Scan JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1] [CustomerID#29466,Date#29467,Consumption#29468] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Date:string,Consumption:double>\n                        +- Sort [CustomerID#29446 ASC NULLS FIRST], false, 0\n                          +- Exchange hashpartitioning(CustomerID#29446, 200), ENSURE_REQUIREMENTS, [plan_id=48609]\n                              +- Scan JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1] [CustomerID#29446,Segment#29447] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Segment:string>\n\n4. Explain output:\n----------------------------------------\n\nPhysical Plan ==:\n-----------------\n  AdaptiveSparkPlan isFinalPlan=false\n  +- Sort [Percentage_Increase#29540 DESC NULLS LAST], true, 0\n  +- Exchange rangepartitioning(Percentage_Increase#29540 DESC NULLS LAST, 200), ENSURE_REQUIREMENTS, [plan_id=48671]\n  +- Project [Segment#29447, _aggregateexpression#29545 AS Consumption_2012#29537, _aggregateexpression#29546 AS Consumption_2013#29538, (_aggregateexpression#29546 - _aggregateexpression#29545) AS Increase_Decrease#29539, (((_aggregateexpression#29546 - _aggregateexpression#29545) / if ((_aggregateexpression#29546 = 0.0)) null else _aggregateexpression#29546) * 100.0) AS Percentage_Increase#29540]\n  +- HashAggregate(keys=[Segment#29447], functions=[sum(CASE WHEN (substring(Date#29467, 1, 4) = 2012) THEN Consumption#29468 ELSE 0.0 END), sum(CASE WHEN (substring(Date#29467, 1, 4) = 2013) THEN Consumption#29468 ELSE 0.0 END)])\n  +- Exchange hashpartitioning(Segment#29447, 200), ENSURE_REQUIREMENTS, [plan_id=48667]\n  +- HashAggregate(keys=[Segment#29447], functions=[partial_sum(CASE WHEN (substring(Date#29467, 1, 4) = 2012) THEN Consumption#29468 ELSE 0.0 END), partial_sum(CASE WHEN (substring(Date#29467, 1, 4) = 2013) THEN Consumption#29468 ELSE 0.0 END)])\n  +- Project [Date#29467, Consumption#29468, Segment#29447]\n  +- SortMergeJoin [CustomerID#29466], [CustomerID#29446], Inner\n  :- Sort [CustomerID#29466 ASC NULLS FIRST], false, 0\n  :  +- Exchange hashpartitioning(CustomerID#29466, 200), ENSURE_REQUIREMENTS, [plan_id=48659]\n  :     +- Filter substring(Date#29467, 1, 4) IN (2012,2013)\n  :        +- Scan JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1] [CustomerID#29466,Date#29467,Consumption#29468] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Date:string,Consumption:double>\n  +- Sort [CustomerID#29446 ASC NULLS FIRST], false, 0\n  +- Exchange hashpartitioning(CustomerID#29446, 200), ENSURE_REQUIREMENTS, [plan_id=48660]\n  +- Scan JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1] [CustomerID#29446,Segment#29447] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Segment:string>\n================================================================================"
    },
    "result_file_path": "/home/lars/Privat/RWTH/Auslandssemester/#KURSE/Safe Distributed Systems/Exercises/Practical_Exercise/NL2SQL2SPARK/RAW_RESULTS/benchmark_results_20260101_google_ce2b3070/1482/20260101_124934_ID_1482_ITER_6_3eb19741.json",
    "explainer_metrics": {
        "golden_query": {
            "shuffle_count": {
                "Exchange\\s+hashpartitioning\\(": 2,
                "Exchange\\s+rangepartitioning\\(": 0,
                "Exchange\\s+SinglePartition": 1,
                "ShuffleExchange": 0,
                "TOTAL": 3
            },
            "has_broadcast_join": false,
            "has_predicate_pushdown": true,
            "pushed_filters": [
                {
                    "scan_line": ":     +- Scan JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1] [CustomerID#29446,Segment#29447] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Segment:string>",
                    "filters": [
                        "*IsNotNull(CustomerID)"
                    ]
                },
                {
                    "scan_line": "+- Scan JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1] [CustomerID#29466,Date#29467,Consumption#29468] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Date:string,Consumption:double>",
                    "filters": [
                        "*IsNotNull(CustomerID)"
                    ]
                },
                {
                    "scan_line": ":     +- Scan JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1] [CustomerID#29446,Segment#29447] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Segment:string>",
                    "filters": [
                        "*IsNotNull(CustomerID)"
                    ]
                },
                {
                    "scan_line": "+- Scan JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1] [CustomerID#29466,Date#29467,Consumption#29468] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Date:string,Consumption:double>",
                    "filters": [
                        "*IsNotNull(CustomerID)"
                    ]
                }
            ],
            "filter_count_before_optimization": 0,
            "filter_count_after_optimization": 2
        },
        "model_query": {
            "shuffle_count": {
                "Exchange\\s+hashpartitioning\\(": 3,
                "Exchange\\s+rangepartitioning\\(": 1,
                "Exchange\\s+SinglePartition": 0,
                "ShuffleExchange": 0,
                "TOTAL": 4
            },
            "has_broadcast_join": false,
            "has_predicate_pushdown": true,
            "pushed_filters": [
                {
                    "scan_line": ":        +- Scan JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1] [CustomerID#29466,Date#29467,Consumption#29468] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Date:string,Consumption:double>",
                    "filters": [
                        "*IsNotNull(CustomerID)"
                    ]
                },
                {
                    "scan_line": "+- Scan JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1] [CustomerID#29446,Segment#29447] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Segment:string>",
                    "filters": [
                        "*IsNotNull(CustomerID)"
                    ]
                },
                {
                    "scan_line": ":        +- Scan JDBCRelation((SELECT \"CustomerID\", \"Date\", \"Consumption\" FROM \"yearmonth\") AS \"yearmonth\") [numPartitions=1] [CustomerID#29466,Date#29467,Consumption#29468] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Date:string,Consumption:double>",
                    "filters": [
                        "*IsNotNull(CustomerID)"
                    ]
                },
                {
                    "scan_line": "+- Scan JDBCRelation((SELECT \"CustomerID\", \"Segment\", \"Currency\" FROM \"customers\") AS \"customers\") [numPartitions=1] [CustomerID#29446,Segment#29447] PushedFilters: [*IsNotNull(CustomerID)], ReadSchema: struct<CustomerID:int,Segment:string>",
                    "filters": [
                        "*IsNotNull(CustomerID)"
                    ]
                }
            ],
            "filter_count_before_optimization": 0,
            "filter_count_after_optimization": 2
        },
        "plan_equivalence": {
            "golden_vs_model_physical_equivalent": false
        }
    }
}